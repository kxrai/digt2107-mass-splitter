{"ast":null,"code":"'use strict';\n\n// connection mixins\n// implementation of http://dev.mysql.com/doc/internals/en/compression.html\nconst zlib = require('zlib');\nconst PacketParser = require('./packet_parser.js');\nfunction handleCompressedPacket(packet) {\n  // eslint-disable-next-line consistent-this, no-invalid-this\n  const connection = this;\n  const deflatedLength = packet.readInt24();\n  const body = packet.readBuffer();\n  if (deflatedLength !== 0) {\n    connection.inflateQueue.push(task => {\n      zlib.inflate(body, (err, data) => {\n        if (err) {\n          connection._handleNetworkError(err);\n          return;\n        }\n        connection._bumpCompressedSequenceId(packet.numPackets);\n        connection._inflatedPacketsParser.execute(data);\n        task.done();\n      });\n    });\n  } else {\n    connection.inflateQueue.push(task => {\n      connection._bumpCompressedSequenceId(packet.numPackets);\n      connection._inflatedPacketsParser.execute(body);\n      task.done();\n    });\n  }\n}\nfunction writeCompressed(buffer) {\n  // http://dev.mysql.com/doc/internals/en/example-several-mysql-packets.html\n  // note: sending a MySQL Packet of the size 2^24−5 to 2^24−1 via compression\n  // leads to at least one extra compressed packet.\n  // (this is because \"length of the packet before compression\" need to fit\n  // into 3 byte unsigned int. \"length of the packet before compression\" includes\n  // 4 byte packet header, hence 2^24−5)\n  const MAX_COMPRESSED_LENGTH = 16777210;\n  let start;\n  if (buffer.length > MAX_COMPRESSED_LENGTH) {\n    for (start = 0; start < buffer.length; start += MAX_COMPRESSED_LENGTH) {\n      writeCompressed.call(\n      // eslint-disable-next-line no-invalid-this\n      this, buffer.slice(start, start + MAX_COMPRESSED_LENGTH));\n    }\n    return;\n  }\n\n  // eslint-disable-next-line no-invalid-this, consistent-this\n  const connection = this;\n  let packetLen = buffer.length;\n  const compressHeader = Buffer.allocUnsafe(7);\n\n  // seqqueue is used here because zlib async execution is routed via thread pool\n  // internally and when we have multiple compressed packets arriving we need\n  // to assemble uncompressed result sequentially\n  (function (seqId) {\n    connection.deflateQueue.push(task => {\n      zlib.deflate(buffer, (err, compressed) => {\n        if (err) {\n          connection._handleFatalError(err);\n          return;\n        }\n        let compressedLength = compressed.length;\n        if (compressedLength < packetLen) {\n          compressHeader.writeUInt8(compressedLength & 0xff, 0);\n          compressHeader.writeUInt16LE(compressedLength >> 8, 1);\n          compressHeader.writeUInt8(seqId, 3);\n          compressHeader.writeUInt8(packetLen & 0xff, 4);\n          compressHeader.writeUInt16LE(packetLen >> 8, 5);\n          connection.writeUncompressed(compressHeader);\n          connection.writeUncompressed(compressed);\n        } else {\n          // http://dev.mysql.com/doc/internals/en/uncompressed-payload.html\n          // To send an uncompressed payload:\n          //   - set length of payload before compression to 0\n          //   - the compressed payload contains the uncompressed payload instead.\n          compressedLength = packetLen;\n          packetLen = 0;\n          compressHeader.writeUInt8(compressedLength & 0xff, 0);\n          compressHeader.writeUInt16LE(compressedLength >> 8, 1);\n          compressHeader.writeUInt8(seqId, 3);\n          compressHeader.writeUInt8(packetLen & 0xff, 4);\n          compressHeader.writeUInt16LE(packetLen >> 8, 5);\n          connection.writeUncompressed(compressHeader);\n          connection.writeUncompressed(buffer);\n        }\n        task.done();\n      });\n    });\n  })(connection.compressedSequenceId);\n  connection._bumpCompressedSequenceId(1);\n}\nfunction enableCompression(connection) {\n  connection._lastWrittenPacketId = 0;\n  connection._lastReceivedPacketId = 0;\n  connection._handleCompressedPacket = handleCompressedPacket;\n  connection._inflatedPacketsParser = new PacketParser(p => {\n    connection.handlePacket(p);\n  }, 4);\n  connection._inflatedPacketsParser._lastPacket = 0;\n  connection.packetParser = new PacketParser(packet => {\n    connection._handleCompressedPacket(packet);\n  }, 7);\n  connection.writeUncompressed = connection.write;\n  connection.write = writeCompressed;\n  const seqqueue = require('seq-queue');\n  connection.inflateQueue = seqqueue.createQueue();\n  connection.deflateQueue = seqqueue.createQueue();\n}\nmodule.exports = {\n  enableCompression: enableCompression\n};","map":{"version":3,"names":["zlib","require","PacketParser","handleCompressedPacket","packet","connection","deflatedLength","readInt24","body","readBuffer","inflateQueue","push","task","inflate","err","data","_handleNetworkError","_bumpCompressedSequenceId","numPackets","_inflatedPacketsParser","execute","done","writeCompressed","buffer","MAX_COMPRESSED_LENGTH","start","length","call","slice","packetLen","compressHeader","Buffer","allocUnsafe","seqId","deflateQueue","deflate","compressed","_handleFatalError","compressedLength","writeUInt8","writeUInt16LE","writeUncompressed","compressedSequenceId","enableCompression","_lastWrittenPacketId","_lastReceivedPacketId","_handleCompressedPacket","p","handlePacket","_lastPacket","packetParser","write","seqqueue","createQueue","module","exports"],"sources":["C:/Users/LENOVO/Documents/digt2107-mass-splitter/client/node_modules/mysql2/lib/compressed_protocol.js"],"sourcesContent":["'use strict';\r\n\r\n// connection mixins\r\n// implementation of http://dev.mysql.com/doc/internals/en/compression.html\r\n\r\nconst zlib = require('zlib');\r\nconst PacketParser = require('./packet_parser.js');\r\n\r\nfunction handleCompressedPacket(packet) {\r\n  // eslint-disable-next-line consistent-this, no-invalid-this\r\n  const connection = this;\r\n  const deflatedLength = packet.readInt24();\r\n  const body = packet.readBuffer();\r\n\r\n  if (deflatedLength !== 0) {\r\n    connection.inflateQueue.push(task => {\r\n      zlib.inflate(body, (err, data) => {\r\n        if (err) {\r\n          connection._handleNetworkError(err);\r\n          return;\r\n        }\r\n        connection._bumpCompressedSequenceId(packet.numPackets);\r\n        connection._inflatedPacketsParser.execute(data);\r\n        task.done();\r\n      });\r\n    });\r\n  } else {\r\n    connection.inflateQueue.push(task => {\r\n      connection._bumpCompressedSequenceId(packet.numPackets);\r\n      connection._inflatedPacketsParser.execute(body);\r\n      task.done();\r\n    });\r\n  }\r\n}\r\n\r\nfunction writeCompressed(buffer) {\r\n  // http://dev.mysql.com/doc/internals/en/example-several-mysql-packets.html\r\n  // note: sending a MySQL Packet of the size 2^24−5 to 2^24−1 via compression\r\n  // leads to at least one extra compressed packet.\r\n  // (this is because \"length of the packet before compression\" need to fit\r\n  // into 3 byte unsigned int. \"length of the packet before compression\" includes\r\n  // 4 byte packet header, hence 2^24−5)\r\n  const MAX_COMPRESSED_LENGTH = 16777210;\r\n  let start;\r\n  if (buffer.length > MAX_COMPRESSED_LENGTH) {\r\n    for (start = 0; start < buffer.length; start += MAX_COMPRESSED_LENGTH) {\r\n      writeCompressed.call(\r\n        // eslint-disable-next-line no-invalid-this\r\n        this,\r\n        buffer.slice(start, start + MAX_COMPRESSED_LENGTH)\r\n      );\r\n    }\r\n    return;\r\n  }\r\n\r\n  // eslint-disable-next-line no-invalid-this, consistent-this\r\n  const connection = this;\r\n\r\n  let packetLen = buffer.length;\r\n  const compressHeader = Buffer.allocUnsafe(7);\r\n\r\n  // seqqueue is used here because zlib async execution is routed via thread pool\r\n  // internally and when we have multiple compressed packets arriving we need\r\n  // to assemble uncompressed result sequentially\r\n  (function(seqId) {\r\n    connection.deflateQueue.push(task => {\r\n      zlib.deflate(buffer, (err, compressed) => {\r\n        if (err) {\r\n          connection._handleFatalError(err);\r\n          return;\r\n        }\r\n        let compressedLength = compressed.length;\r\n\r\n        if (compressedLength < packetLen) {\r\n          compressHeader.writeUInt8(compressedLength & 0xff, 0);\r\n          compressHeader.writeUInt16LE(compressedLength >> 8, 1);\r\n          compressHeader.writeUInt8(seqId, 3);\r\n          compressHeader.writeUInt8(packetLen & 0xff, 4);\r\n          compressHeader.writeUInt16LE(packetLen >> 8, 5);\r\n          connection.writeUncompressed(compressHeader);\r\n          connection.writeUncompressed(compressed);\r\n        } else {\r\n          // http://dev.mysql.com/doc/internals/en/uncompressed-payload.html\r\n          // To send an uncompressed payload:\r\n          //   - set length of payload before compression to 0\r\n          //   - the compressed payload contains the uncompressed payload instead.\r\n          compressedLength = packetLen;\r\n          packetLen = 0;\r\n          compressHeader.writeUInt8(compressedLength & 0xff, 0);\r\n          compressHeader.writeUInt16LE(compressedLength >> 8, 1);\r\n          compressHeader.writeUInt8(seqId, 3);\r\n          compressHeader.writeUInt8(packetLen & 0xff, 4);\r\n          compressHeader.writeUInt16LE(packetLen >> 8, 5);\r\n          connection.writeUncompressed(compressHeader);\r\n          connection.writeUncompressed(buffer);\r\n        }\r\n        task.done();\r\n      });\r\n    });\r\n  })(connection.compressedSequenceId);\r\n  connection._bumpCompressedSequenceId(1);\r\n}\r\n\r\nfunction enableCompression(connection) {\r\n  connection._lastWrittenPacketId = 0;\r\n  connection._lastReceivedPacketId = 0;\r\n\r\n  connection._handleCompressedPacket = handleCompressedPacket;\r\n  connection._inflatedPacketsParser = new PacketParser(p => {\r\n    connection.handlePacket(p);\r\n  }, 4);\r\n  connection._inflatedPacketsParser._lastPacket = 0;\r\n  connection.packetParser = new PacketParser(packet => {\r\n    connection._handleCompressedPacket(packet);\r\n  }, 7);\r\n\r\n  connection.writeUncompressed = connection.write;\r\n  connection.write = writeCompressed;\r\n\r\n  const seqqueue = require('seq-queue');\r\n  connection.inflateQueue = seqqueue.createQueue();\r\n  connection.deflateQueue = seqqueue.createQueue();\r\n}\r\n\r\nmodule.exports = {\r\n  enableCompression: enableCompression\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}