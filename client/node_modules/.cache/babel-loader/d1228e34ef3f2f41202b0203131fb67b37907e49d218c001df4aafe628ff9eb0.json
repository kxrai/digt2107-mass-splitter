{"ast":null,"code":"'use strict';\n\nconst FieldFlags = require('../constants/field_flags.js');\nconst Charsets = require('../constants/charsets.js');\nconst Types = require('../constants/types.js');\nconst helpers = require('../helpers');\nconst genFunc = require('generate-function');\nconst parserCache = require('./parser_cache.js');\nconst typeNames = [];\nfor (const t in Types) {\n  typeNames[Types[t]] = t;\n}\nfunction readCodeFor(field, config, options, fieldNum) {\n  const supportBigNumbers = Boolean(options.supportBigNumbers || config.supportBigNumbers);\n  const bigNumberStrings = Boolean(options.bigNumberStrings || config.bigNumberStrings);\n  const timezone = options.timezone || config.timezone;\n  const dateStrings = options.dateStrings || config.dateStrings;\n  const unsigned = field.flags & FieldFlags.UNSIGNED;\n  switch (field.columnType) {\n    case Types.TINY:\n      return unsigned ? 'packet.readInt8();' : 'packet.readSInt8();';\n    case Types.SHORT:\n      return unsigned ? 'packet.readInt16();' : 'packet.readSInt16();';\n    case Types.LONG:\n    case Types.INT24:\n      // in binary protocol int24 is encoded in 4 bytes int32\n      return unsigned ? 'packet.readInt32();' : 'packet.readSInt32();';\n    case Types.YEAR:\n      return 'packet.readInt16()';\n    case Types.FLOAT:\n      return 'packet.readFloat();';\n    case Types.DOUBLE:\n      return 'packet.readDouble();';\n    case Types.NULL:\n      return 'null;';\n    case Types.DATE:\n    case Types.DATETIME:\n    case Types.TIMESTAMP:\n    case Types.NEWDATE:\n      if (helpers.typeMatch(field.columnType, dateStrings, Types)) {\n        return `packet.readDateTimeString(${parseInt(field.decimals, 10)});`;\n      }\n      return `packet.readDateTime(${helpers.srcEscape(timezone)});`;\n    case Types.TIME:\n      return 'packet.readTimeString()';\n    case Types.DECIMAL:\n    case Types.NEWDECIMAL:\n      if (config.decimalNumbers) {\n        return 'packet.parseLengthCodedFloat();';\n      }\n      return 'packet.readLengthCodedString(\"ascii\");';\n    case Types.GEOMETRY:\n      return 'packet.parseGeometryValue();';\n    case Types.VECTOR:\n      return 'packet.parseVector()';\n    case Types.JSON:\n      // Since for JSON columns mysql always returns charset 63 (BINARY),\n      // we have to handle it according to JSON specs and use \"utf8\",\n      // see https://github.com/sidorares/node-mysql2/issues/409\n      return config.jsonStrings ? 'packet.readLengthCodedString(\"utf8\")' : 'JSON.parse(packet.readLengthCodedString(\"utf8\"));';\n    case Types.LONGLONG:\n      if (!supportBigNumbers) {\n        return unsigned ? 'packet.readInt64JSNumber();' : 'packet.readSInt64JSNumber();';\n      }\n      if (bigNumberStrings) {\n        return unsigned ? 'packet.readInt64String();' : 'packet.readSInt64String();';\n      }\n      return unsigned ? 'packet.readInt64();' : 'packet.readSInt64();';\n    default:\n      if (field.characterSet === Charsets.BINARY) {\n        return 'packet.readLengthCodedBuffer();';\n      }\n      return `packet.readLengthCodedString(fields[${fieldNum}].encoding)`;\n  }\n}\nfunction compile(fields, options, config) {\n  const parserFn = genFunc();\n  const nullBitmapLength = Math.floor((fields.length + 7 + 2) / 8);\n  function wrap(field, packet) {\n    return {\n      type: typeNames[field.columnType],\n      length: field.columnLength,\n      db: field.schema,\n      table: field.table,\n      name: field.name,\n      string: function (encoding = field.encoding) {\n        if (field.columnType === Types.JSON && encoding === field.encoding) {\n          // Since for JSON columns mysql always returns charset 63 (BINARY),\n          // we have to handle it according to JSON specs and use \"utf8\",\n          // see https://github.com/sidorares/node-mysql2/issues/1661\n          console.warn(`typeCast: JSON column \"${field.name}\" is interpreted as BINARY by default, recommended to manually set utf8 encoding: \\`field.string(\"utf8\")\\``);\n        }\n        if ([Types.DATETIME, Types.NEWDATE, Types.TIMESTAMP, Types.DATE].includes(field.columnType)) {\n          return packet.readDateTimeString(parseInt(field.decimals, 10));\n        }\n        if (field.columnType === Types.TINY) {\n          const unsigned = field.flags & FieldFlags.UNSIGNED;\n          return String(unsigned ? packet.readInt8() : packet.readSInt8());\n        }\n        if (field.columnType === Types.TIME) {\n          return packet.readTimeString();\n        }\n        return packet.readLengthCodedString(encoding);\n      },\n      buffer: function () {\n        return packet.readLengthCodedBuffer();\n      },\n      geometry: function () {\n        return packet.parseGeometryValue();\n      }\n    };\n  }\n  parserFn('(function(){');\n  parserFn('return class BinaryRow {');\n  parserFn('constructor() {');\n  parserFn('}');\n  parserFn('next(packet, fields, options) {');\n  if (options.rowsAsArray) {\n    parserFn(`const result = new Array(${fields.length});`);\n  } else {\n    parserFn('const result = {};');\n  }\n\n  // Global typeCast\n  if (typeof config.typeCast === 'function' && typeof options.typeCast !== 'function') {\n    options.typeCast = config.typeCast;\n  }\n  parserFn('packet.readInt8();'); // status byte\n  for (let i = 0; i < nullBitmapLength; ++i) {\n    parserFn(`const nullBitmaskByte${i} = packet.readInt8();`);\n  }\n  let lvalue = '';\n  let currentFieldNullBit = 4;\n  let nullByteIndex = 0;\n  let fieldName = '';\n  let tableName = '';\n  for (let i = 0; i < fields.length; i++) {\n    fieldName = helpers.fieldEscape(fields[i].name);\n    // parserFn(`// ${fieldName}: ${typeNames[fields[i].columnType]}`);\n\n    if (typeof options.nestTables === 'string') {\n      lvalue = `result[${helpers.fieldEscape(fields[i].table + options.nestTables + fields[i].name)}]`;\n    } else if (options.nestTables === true) {\n      tableName = helpers.fieldEscape(fields[i].table);\n      parserFn(`if (!result[${tableName}]) result[${tableName}] = {};`);\n      lvalue = `result[${tableName}][${fieldName}]`;\n    } else if (options.rowsAsArray) {\n      lvalue = `result[${i.toString(10)}]`;\n    } else {\n      lvalue = `result[${fieldName}]`;\n    }\n    parserFn(`if (nullBitmaskByte${nullByteIndex} & ${currentFieldNullBit}) `);\n    parserFn(`${lvalue} = null;`);\n    parserFn('else {');\n    if (options.typeCast === false) {\n      parserFn(`${lvalue} = packet.readLengthCodedBuffer();`);\n    } else {\n      const fieldWrapperVar = `fieldWrapper${i}`;\n      parserFn(`const ${fieldWrapperVar} = wrap(fields[${i}], packet);`);\n      const readCode = readCodeFor(fields[i], config, options, i);\n      if (typeof options.typeCast === 'function') {\n        parserFn(`${lvalue} = options.typeCast(${fieldWrapperVar}, function() { return ${readCode} });`);\n      } else {\n        parserFn(`${lvalue} = ${readCode};`);\n      }\n    }\n    parserFn('}');\n    currentFieldNullBit *= 2;\n    if (currentFieldNullBit === 0x100) {\n      currentFieldNullBit = 1;\n      nullByteIndex++;\n    }\n  }\n  parserFn('return result;');\n  parserFn('}');\n  parserFn('};')('})()');\n  if (config.debug) {\n    helpers.printDebugWithCode('Compiled binary protocol row parser', parserFn.toString());\n  }\n  return parserFn.toFunction({\n    wrap\n  });\n}\nfunction getBinaryParser(fields, options, config) {\n  return parserCache.getParser('binary', fields, options, config, compile);\n}\nmodule.exports = getBinaryParser;","map":{"version":3,"names":["FieldFlags","require","Charsets","Types","helpers","genFunc","parserCache","typeNames","t","readCodeFor","field","config","options","fieldNum","supportBigNumbers","Boolean","bigNumberStrings","timezone","dateStrings","unsigned","flags","UNSIGNED","columnType","TINY","SHORT","LONG","INT24","YEAR","FLOAT","DOUBLE","NULL","DATE","DATETIME","TIMESTAMP","NEWDATE","typeMatch","parseInt","decimals","srcEscape","TIME","DECIMAL","NEWDECIMAL","decimalNumbers","GEOMETRY","VECTOR","JSON","jsonStrings","LONGLONG","characterSet","BINARY","compile","fields","parserFn","nullBitmapLength","Math","floor","length","wrap","packet","type","columnLength","db","schema","table","name","string","encoding","console","warn","includes","readDateTimeString","String","readInt8","readSInt8","readTimeString","readLengthCodedString","buffer","readLengthCodedBuffer","geometry","parseGeometryValue","rowsAsArray","typeCast","i","lvalue","currentFieldNullBit","nullByteIndex","fieldName","tableName","fieldEscape","nestTables","toString","fieldWrapperVar","readCode","debug","printDebugWithCode","toFunction","getBinaryParser","getParser","module","exports"],"sources":["C:/Users/LENOVO/Documents/digt2107-mass-splitter/client/node_modules/mysql2/lib/parsers/binary_parser.js"],"sourcesContent":["'use strict';\r\n\r\nconst FieldFlags = require('../constants/field_flags.js');\r\nconst Charsets = require('../constants/charsets.js');\r\nconst Types = require('../constants/types.js');\r\nconst helpers = require('../helpers');\r\nconst genFunc = require('generate-function');\r\nconst parserCache = require('./parser_cache.js');\r\nconst typeNames = [];\r\nfor (const t in Types) {\r\n  typeNames[Types[t]] = t;\r\n}\r\n\r\nfunction readCodeFor(field, config, options, fieldNum) {\r\n  const supportBigNumbers = Boolean(\r\n    options.supportBigNumbers || config.supportBigNumbers,\r\n  );\r\n  const bigNumberStrings = Boolean(\r\n    options.bigNumberStrings || config.bigNumberStrings,\r\n  );\r\n  const timezone = options.timezone || config.timezone;\r\n  const dateStrings = options.dateStrings || config.dateStrings;\r\n  const unsigned = field.flags & FieldFlags.UNSIGNED;\r\n  switch (field.columnType) {\r\n    case Types.TINY:\r\n      return unsigned ? 'packet.readInt8();' : 'packet.readSInt8();';\r\n    case Types.SHORT:\r\n      return unsigned ? 'packet.readInt16();' : 'packet.readSInt16();';\r\n    case Types.LONG:\r\n    case Types.INT24: // in binary protocol int24 is encoded in 4 bytes int32\r\n      return unsigned ? 'packet.readInt32();' : 'packet.readSInt32();';\r\n    case Types.YEAR:\r\n      return 'packet.readInt16()';\r\n    case Types.FLOAT:\r\n      return 'packet.readFloat();';\r\n    case Types.DOUBLE:\r\n      return 'packet.readDouble();';\r\n    case Types.NULL:\r\n      return 'null;';\r\n    case Types.DATE:\r\n    case Types.DATETIME:\r\n    case Types.TIMESTAMP:\r\n    case Types.NEWDATE:\r\n      if (helpers.typeMatch(field.columnType, dateStrings, Types)) {\r\n        return `packet.readDateTimeString(${parseInt(field.decimals, 10)});`;\r\n      }\r\n      return `packet.readDateTime(${helpers.srcEscape(timezone)});`;\r\n    case Types.TIME:\r\n      return 'packet.readTimeString()';\r\n    case Types.DECIMAL:\r\n    case Types.NEWDECIMAL:\r\n      if (config.decimalNumbers) {\r\n        return 'packet.parseLengthCodedFloat();';\r\n      }\r\n      return 'packet.readLengthCodedString(\"ascii\");';\r\n    case Types.GEOMETRY:\r\n      return 'packet.parseGeometryValue();';\r\n    case Types.VECTOR:\r\n      return 'packet.parseVector()';  \r\n    case Types.JSON:\r\n      // Since for JSON columns mysql always returns charset 63 (BINARY),\r\n      // we have to handle it according to JSON specs and use \"utf8\",\r\n      // see https://github.com/sidorares/node-mysql2/issues/409\r\n      return config.jsonStrings ? 'packet.readLengthCodedString(\"utf8\")' : 'JSON.parse(packet.readLengthCodedString(\"utf8\"));';\r\n    case Types.LONGLONG:\r\n      if (!supportBigNumbers) {\r\n        return unsigned\r\n          ? 'packet.readInt64JSNumber();'\r\n          : 'packet.readSInt64JSNumber();';\r\n      }\r\n      if (bigNumberStrings) {\r\n        return unsigned\r\n          ? 'packet.readInt64String();'\r\n          : 'packet.readSInt64String();';\r\n      }\r\n      return unsigned ? 'packet.readInt64();' : 'packet.readSInt64();';\r\n\r\n    default:\r\n      if (field.characterSet === Charsets.BINARY) {\r\n        return 'packet.readLengthCodedBuffer();';\r\n      }\r\n      return `packet.readLengthCodedString(fields[${fieldNum}].encoding)`;\r\n  }\r\n}\r\n\r\nfunction compile(fields, options, config) {\r\n  const parserFn = genFunc();\r\n  const nullBitmapLength = Math.floor((fields.length + 7 + 2) / 8);\r\n\r\n  function wrap(field, packet) {\r\n    return {\r\n      type: typeNames[field.columnType],\r\n      length: field.columnLength,\r\n      db: field.schema,\r\n      table: field.table,\r\n      name: field.name,\r\n      string: function (encoding = field.encoding) {\r\n        if (field.columnType === Types.JSON && encoding === field.encoding) {\r\n          // Since for JSON columns mysql always returns charset 63 (BINARY),\r\n          // we have to handle it according to JSON specs and use \"utf8\",\r\n          // see https://github.com/sidorares/node-mysql2/issues/1661\r\n          console.warn(\r\n            `typeCast: JSON column \"${field.name}\" is interpreted as BINARY by default, recommended to manually set utf8 encoding: \\`field.string(\"utf8\")\\``,\r\n          );\r\n        }\r\n\r\n        if (\r\n          [Types.DATETIME, Types.NEWDATE, Types.TIMESTAMP, Types.DATE].includes(\r\n            field.columnType,\r\n          )\r\n        ) {\r\n          return packet.readDateTimeString(parseInt(field.decimals, 10));\r\n        }\r\n\r\n        if (field.columnType === Types.TINY) {\r\n          const unsigned = field.flags & FieldFlags.UNSIGNED;\r\n\r\n          return String(unsigned ? packet.readInt8() : packet.readSInt8());\r\n        }\r\n\r\n        if (field.columnType === Types.TIME) {\r\n          return packet.readTimeString();\r\n        }\r\n\r\n        return packet.readLengthCodedString(encoding);\r\n      },\r\n      buffer: function () {\r\n        return packet.readLengthCodedBuffer();\r\n      },\r\n      geometry: function () {\r\n        return packet.parseGeometryValue();\r\n      },\r\n    };\r\n  }\r\n\r\n  parserFn('(function(){');\r\n  parserFn('return class BinaryRow {');\r\n  parserFn('constructor() {');\r\n  parserFn('}');\r\n\r\n  parserFn('next(packet, fields, options) {');\r\n  if (options.rowsAsArray) {\r\n    parserFn(`const result = new Array(${fields.length});`);\r\n  } else {\r\n    parserFn('const result = {};');\r\n  }\r\n\r\n  // Global typeCast\r\n  if (\r\n    typeof config.typeCast === 'function' &&\r\n    typeof options.typeCast !== 'function'\r\n  ) {\r\n    options.typeCast = config.typeCast;\r\n  }\r\n\r\n  parserFn('packet.readInt8();'); // status byte\r\n  for (let i = 0; i < nullBitmapLength; ++i) {\r\n    parserFn(`const nullBitmaskByte${i} = packet.readInt8();`);\r\n  }\r\n\r\n  let lvalue = '';\r\n  let currentFieldNullBit = 4;\r\n  let nullByteIndex = 0;\r\n  let fieldName = '';\r\n  let tableName = '';\r\n\r\n  for (let i = 0; i < fields.length; i++) {\r\n    fieldName = helpers.fieldEscape(fields[i].name);\r\n    // parserFn(`// ${fieldName}: ${typeNames[fields[i].columnType]}`);\r\n\r\n    if (typeof options.nestTables === 'string') {\r\n      lvalue = `result[${helpers.fieldEscape(fields[i].table + options.nestTables + fields[i].name)}]`;\r\n    } else if (options.nestTables === true) {\r\n      tableName = helpers.fieldEscape(fields[i].table);\r\n\r\n      parserFn(`if (!result[${tableName}]) result[${tableName}] = {};`);\r\n      lvalue = `result[${tableName}][${fieldName}]`;\r\n    } else if (options.rowsAsArray) {\r\n      lvalue = `result[${i.toString(10)}]`;\r\n    } else {\r\n      lvalue = `result[${fieldName}]`;\r\n    }\r\n\r\n    parserFn(`if (nullBitmaskByte${nullByteIndex} & ${currentFieldNullBit}) `);\r\n    parserFn(`${lvalue} = null;`);\r\n    parserFn('else {');\r\n\r\n    if (options.typeCast === false) {\r\n      parserFn(`${lvalue} = packet.readLengthCodedBuffer();`);\r\n    } else {\r\n      const fieldWrapperVar = `fieldWrapper${i}`;\r\n      parserFn(`const ${fieldWrapperVar} = wrap(fields[${i}], packet);`);\r\n      const readCode = readCodeFor(fields[i], config, options, i);\r\n\r\n      if (typeof options.typeCast === 'function') {\r\n        parserFn(\r\n          `${lvalue} = options.typeCast(${fieldWrapperVar}, function() { return ${readCode} });`,\r\n        );\r\n      } else {\r\n        parserFn(`${lvalue} = ${readCode};`);\r\n      }\r\n    }\r\n    parserFn('}');\r\n\r\n    currentFieldNullBit *= 2;\r\n    if (currentFieldNullBit === 0x100) {\r\n      currentFieldNullBit = 1;\r\n      nullByteIndex++;\r\n    }\r\n  }\r\n\r\n  parserFn('return result;');\r\n  parserFn('}');\r\n  parserFn('};')('})()');\r\n\r\n  if (config.debug) {\r\n    helpers.printDebugWithCode(\r\n      'Compiled binary protocol row parser',\r\n      parserFn.toString(),\r\n    );\r\n  }\r\n  return parserFn.toFunction({ wrap });\r\n}\r\n\r\nfunction getBinaryParser(fields, options, config) {\r\n  return parserCache.getParser('binary', fields, options, config, compile);\r\n}\r\n\r\nmodule.exports = getBinaryParser;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}